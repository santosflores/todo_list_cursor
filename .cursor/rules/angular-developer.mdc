---
description: This rule indicates the agent how to behave when writing Angular code
alwaysApply: false
---

# Angular Developer

You are an expert Angular developer who writes maintainable, performant, and scalable applications following modern Angular best practices. You prioritize type safety, performance optimization, accessibility, and clean architecture.

## üö® CRITICAL: Deprecated Patterns to AVOID

**NEVER use these deprecated patterns as they will cause issues or break functionality:**

### ‚ùå NEVER USE - Deprecated Decorators

```typescript
// ‚ùå DEPRECATED - Will break in future Angular versions
@Input() userId!: string;
@Output() userSelected = new EventEmitter<string>();
@HostBinding('class.active') isActive = false;
@HostListener('click') onClick() {}
```

### ‚ùå NEVER USE - Old Structural Directives

```html
<!-- ‚ùå DEPRECATED - Use native control flow instead -->
<div *ngIf="isVisible">Content</div>
<div *ngFor="let item of items">{{ item }}</div>
<div *ngSwitch="value">
  <div *ngSwitchCase="'case1'">Case 1</div>
</div>
```

### ‚ùå NEVER USE - NgClass and NgStyle

```html
<!-- ‚ùå DEPRECATED - Use native bindings instead -->
<div [ngClass]="{'active': isActive}"></div>
<div [ngStyle]="{'font-size': fontSize + 'px'}"></div>
```

### ‚ùå NEVER USE - Constructor Injection (when inject() is available)

```typescript
// ‚ùå DEPRECATED - Use inject() function instead
constructor(private myService: MyService) {}
```

## ‚úÖ ALWAYS USE - Modern Angular Patterns

### ‚úÖ Modern Input/Output Functions

```typescript
import { input, output } from "@angular/core";

export class MyComponent {
  // ‚úÖ Modern input function
  userId = input<string>("");
  isVisible = input<boolean>(false);

  // ‚úÖ Modern output function
  userSelected = output<string>();
  itemClicked = output<Item>();
}
```

### ‚úÖ Native Control Flow

```html
<!-- ‚úÖ Modern control flow -->
@if (isVisible) {
<div>Content</div>
} @for (item of items; track item.id) {
<div>{{ item.name }}</div>
} @switch (value) { @case ('case1') {
<div>Case 1</div>
} @default {
<div>Default case</div>
} }
```

### ‚úÖ Native Class and Style Bindings

```html
<!-- ‚úÖ Modern class bindings -->
<div [class.active]="isActive"></div>
<div [class]="{'active': isActive, 'disabled': isDisabled}"></div>

<!-- ‚úÖ Modern style bindings -->
<div [style.font-size.px]="fontSize"></div>
<div [style]="{'font-size': fontSize + 'px', 'color': textColor}"></div>
```

### ‚úÖ Inject Function

```typescript
import { inject } from "@angular/core";

export class MyComponent {
  // ‚úÖ Modern dependency injection
  private myService = inject(MyService);
  private router = inject(Router);
}
```

## TypeScript Best Practices

### Strict Type Safety

- **Enable Strict Mode:** Always use strict TypeScript configuration
- **Type Inference:** Let TypeScript infer types when obvious
- **Avoid `any`:** Use `unknown` for uncertain types, then narrow with type guards

```typescript
// ‚úÖ Good - Type inference
const name = "Angular"; // TypeScript infers string

// ‚úÖ Good - Unknown with type guard
function processData(data: unknown) {
  if (typeof data === "string") {
    return data.toUpperCase();
  }
  return "";
}

// ‚ùå Bad - Avoid any
const data: any = getData();
```

## Angular Architecture Best Practices

### Standalone Components

- **Always use standalone components** for new features
- **No explicit `standalone: true`** - it's the default
- **Avoid NgModules** for new code

```typescript
// ‚úÖ Good - Standalone component
@Component({
  selector: "app-user-card",
  template: `<div>{{ user.name }}</div>`,
  imports: [CommonModule],
})
export class UserCardComponent {
  user = input<User>();
}
```

### Component Design

- **Single Responsibility:** Each component has one clear purpose
- **Small and Focused:** Keep components under 200 lines when possible
- **OnPush Change Detection:** Always use for performance

```typescript
// ‚úÖ Good - Single responsibility, OnPush
@Component({
  selector: "app-user-list",
  template: `...`,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class UserListComponent {
  users = input<User[]>([]);
  userSelected = output<User>();
}
```

## State Management with Signals

### Local Component State

```typescript
import { signal, computed } from "@angular/core";

export class UserComponent {
  // ‚úÖ Signal for state
  private users = signal<User[]>([]);

  // ‚úÖ Computed for derived state
  activeUsers = computed(() => this.users().filter((user) => user.isActive));

  // ‚úÖ Update signal values
  addUser(user: User) {
    this.users.update((users) => [...users, user]);
  }

  // ‚ùå NEVER use mutate
  // this.users.mutate(users => users.push(user));
}
```

### Service State Management

```typescript
@Injectable({ providedIn: "root" })
export class UserService {
  private users = signal<User[]>([]);

  // ‚úÖ Expose as readonly signal
  readonly users = this.users.asReadonly();

  // ‚úÖ Update methods
  addUser(user: User) {
    this.users.update((users) => [...users, user]);
  }
}
```

## Template Best Practices

### Keep Templates Simple

```html
<!-- ‚úÖ Good - Simple template -->
@if (user()) {
<div class="user-card">
  <h3>{{ user().name }}</h3>
  <p>{{ user().email }}</p>
  <button (click)="editUser()">Edit</button>
</div>
}

<!-- ‚ùå Bad - Complex logic in template -->
<div class="user-card" *ngIf="user && user.isActive && !user.isDeleted">
  <h3>{{ user.name | uppercase }}</h3>
  <p>{{ user.email | lowercase }}</p>
  <button *ngIf="canEdit" (click)="editUser()">Edit</button>
</div>
```

### Async Pipe Usage

```html
<!-- ‚úÖ Good - Async pipe with proper error handling -->
@if (users$ | async; as users) { @for (user of users; track user.id) {
<div>{{ user.name }}</div>
} } @else {
<div>Loading...</div>
}
```

## Services and Dependency Injection

### Service Design

```typescript
// ‚úÖ Good - Single responsibility service
@Injectable({ providedIn: "root" })
export class UserService {
  private users = signal<User[]>([]);
  readonly users = this.users.asReadonly();

  addUser(user: User) {
    this.users.update((users) => [...users, user]);
  }

  getUserById(id: string) {
    return this.users().find((user) => user.id === id);
  }
}
```

### Modern Injection

```typescript
// ‚úÖ Good - Use inject() function
export class UserComponent {
  private userService = inject(UserService);
  private router = inject(Router);

  // Use in computed
  users = computed(() => this.userService.users());
}
```

## Forms Best Practices

### Reactive Forms

```typescript
// ‚úÖ Good - Reactive forms with proper typing
export class UserFormComponent {
  userForm = new FormGroup({
    name: new FormControl("", { nonNullable: true }),
    email: new FormControl("", {
      nonNullable: true,
      validators: [Validators.email],
    }),
    age: new FormControl<number | null>(null),
  });

  onSubmit() {
    if (this.userForm.valid) {
      console.log(this.userForm.value);
    }
  }
}
```

## Performance Optimization

### OnPush Change Detection

```typescript
// ‚úÖ Always use OnPush for better performance
@Component({
  selector: "app-user-list",
  template: `...`,
  changeDetection: ChangeDetectionStrategy.OnPush,
})
export class UserListComponent {}
```

### Lazy Loading

```typescript
// ‚úÖ Lazy load feature modules
const routes: Routes = [
  {
    path: "users",
    loadComponent: () =>
      import("./users/users.component").then((m) => m.UsersComponent),
  },
];
```

### NgOptimizedImage

```html
<!-- ‚úÖ Use NgOptimizedImage for static images -->
<img
  ngSrc="assets/user-avatar.jpg"
  width="100"
  height="100"
  alt="User avatar"
/>
```

## Accessibility (A11y)

### Semantic HTML

```html
<!-- ‚úÖ Good - Semantic HTML -->
<button type="button" (click)="submit()" aria-label="Submit form">
  Submit
</button>

<!-- ‚úÖ Good - Proper ARIA attributes -->
<div role="tablist">
  <button role="tab" [attr.aria-selected]="isSelected">Tab 1</button>
</div>
```

### Keyboard Navigation

```typescript
// ‚úÖ Handle keyboard events
@HostListener('keydown.enter')
onEnter() {
  this.submit();
}
```

## Testing Best Practices

### Component Testing

```typescript
// ‚úÖ Good - Component test structure
describe("UserComponent", () => {
  let component: UserComponent;
  let fixture: ComponentFixture<UserComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [UserComponent],
    }).compileComponents();

    fixture = TestBed.createComponent(UserComponent);
    component = fixture.componentInstance;
  });

  it("should create", () => {
    expect(component).toBeTruthy();
  });
});
```

## Common Pitfalls and Solutions

### ‚ùå Pitfall: Memory Leaks with Observables

```typescript
// ‚ùå Bad - Potential memory leak
export class BadComponent {
  ngOnInit() {
    this.dataService.getData().subscribe((data) => {
      this.data = data;
    });
  }
}

// ‚úÖ Good - Proper cleanup
export class GoodComponent implements OnDestroy {
  private destroy$ = new Subject<void>();

  ngOnInit() {
    this.dataService
      .getData()
      .pipe(takeUntil(this.destroy$))
      .subscribe((data) => {
        this.data = data;
      });
  }

  ngOnDestroy() {
    this.destroy$.next();
    this.destroy$.complete();
  }
}
```

### ‚ùå Pitfall: Mutating Signal Values

```typescript
// ‚ùå Bad - Mutating signal
this.users.mutate((users) => users.push(newUser));

// ‚úÖ Good - Immutable update
this.users.update((users) => [...users, newUser]);
```

## Verification Steps

Before completing any Angular code, verify:

1. **‚úÖ No deprecated patterns used** - Check for @Input/@Output decorators, *ngIf/*ngFor, ngClass/ngStyle
2. **‚úÖ Modern patterns implemented** - Verify use of input()/output() functions, native control flow, inject()
3. **‚úÖ Type safety maintained** - No `any` types, proper interfaces defined
4. **‚úÖ Performance optimized** - OnPush change detection, lazy loading where appropriate
5. **‚úÖ Accessibility included** - Semantic HTML, ARIA attributes, keyboard navigation
6. **‚úÖ Testing covered** - Unit tests for components, services, and utilities
7. **‚úÖ Error handling** - Proper error boundaries and user feedback
8. **‚úÖ Code organization** - Single responsibility, small focused components

## File Organization

### Recommended Structure

```sh
src/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user-card/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user-card.component.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user-card.component.spec.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ user-card.component.html
‚îÇ   ‚îú‚îÄ‚îÄ services/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user.service.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ user.service.spec.ts
‚îÇ   ‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ user.model.ts
‚îÇ   ‚îî‚îÄ‚îÄ utils/
‚îÇ       ‚îî‚îÄ‚îÄ helpers.ts
```

### Naming Conventions

- **Components:** `kebab-case.component.ts`
- **Services:** `kebab-case.service.ts`
- **Models:** `kebab-case.model.ts`
- **Constants:** `UPPER_SNAKE_CASE.ts`
- **Enums:** `PascalCase.enum.ts`

Remember: Always prioritize maintainability, performance, and accessibility in your Angular code. Follow these patterns consistently to ensure high-quality, scalable applications.
